# Makefile for /bin/sh
#

PROG=	sh
INSTALLFLAGS= -S
SHSRCS=	alias.c arith_yacc.c arith_yylex.c cd.c echo.c error.c eval.c \
	exec.c expand.c \
	histedit.c input.c jobs.c kill.c mail.c main.c memalloc.c miscbltin.c \
	mystring.c options.c output.c parser.c printf.c redir.c show.c \
	test.c trap.c var.c
GENSRCS= builtins.c nodes.c syntax.c
GENHDRS= builtins.h nodes.h syntax.h token.h
SRCS= ${SHSRCS} ${GENSRCS} ${GENHDRS}

# would be needed if WARNS upgraded to 3, but lets keep the stderr output
# clean, so WARNS has been lowered to 2.
#
# NO_WERROR=	yes # [-Werror=clobbered] on gcc50
WARNS?= 2

# MLINKS for Shell built in commands for which there are no userland
# utilities of the same name are handled with the associated manpage,
# builtin.1 in share/man/man1/.

CFLAGS+=-DSHELL -I. -I${.CURDIR}
# for debug:
# DEBUG_FLAGS+= -g -DDEBUG=2 -fno-inline

.if defined(BOOTSTRAPPING)
CFLAGS+= -DNO_HISTORY
.  if exists(/usr/lib/libedit.a)
DPADD= /usr/lib/libedit.a
LDADD= -ledit
.  elif exists(/usr/lib/libprivate_edit.a)
DPADD= /usr/lib/libprivate_edit.a
LDADD= -lprivate_edit
.  else
DPADD= ${LIBEDIT}
LDADD= -lprivate_edit
LDFLAGS+=	-rpath /lib/priv -L ${_SHLIBDIRPREFIX}/usr/lib/priv
.  endif
.  if exists(/usr/lib/libtermcap.a)
DPADD+= /usr/lib/libtermcap.a
LDADD+= -ltermcap
.  else
DPADD+= ${LIBTERMCAP}
LDADD+= -lprivate_termcap
LDFLAGS+=	-rpath /lib/priv -L /usr/lib/priv
.  endif
.else
DPADD= ${LIBEDIT} ${LIBTERMCAP}
LDADD= -lprivate_edit -lprivate_termcap
LDFLAGS+=	-rpath /lib/priv -L ${_SHLIBDIRPREFIX}/usr/lib/priv
.endif


.PATH:	${.CURDIR}/bltin \
	${.CURDIR}/../kill \
	${.CURDIR}/../test \
	${.CURDIR}/../../usr.bin/printf

CLEANFILES+= mknodes.nx mknodes.no \
	mksyntax.nx mksyntax.no
CLEANFILES+= ${GENSRCS} ${GENHDRS}

build-tools: mknodes.nx mksyntax.nx

.ORDER: builtins.c builtins.h
builtins.c builtins.h: mkbuiltins builtins.def
	sh ${.CURDIR}/mkbuiltins ${.CURDIR}

# XXX this is just to stop the default .c rule being used, so that the
# intermediate object has a fixed name.
# XXX we have a default .c rule, but no default .o rule.
.o:
	${CC} ${CFLAGS} ${LDFLAGS} ${.IMPSRC} ${LDLIBS} -o ${.TARGET}
mknodes.nx: mknodes.no
mksyntax.nx: mksyntax.no

.ORDER: nodes.c nodes.h
nodes.c nodes.h: mknodes.nx nodetypes nodes.c.pat
	./mknodes.nx ${.CURDIR}/nodetypes ${.CURDIR}/nodes.c.pat

.ORDER: syntax.c syntax.h
syntax.c syntax.h: mksyntax.nx
	./mksyntax.nx

token.h: mktokens
	sh ${.CURDIR}/mktokens

regress: sh
	cd ${.CURDIR}/../../tools/regression/bin/sh && ${MAKE} SH=${.OBJDIR}/sh
.include <bsd.prog.mk>
